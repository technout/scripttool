#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 5.6
#  in conjunction with Tcl version 8.6
#    Nov 06, 2020 11:43:28 PM CET  platform: Linux
#    Nov 07, 2020 11:12:27 PM CET  platform: Linux
# 
# Made by Technout <https://github.com/technout>
# Copyright (c) 2020
# 
# TODO:
# 
# 
__version__ = "0.1-2020.11.07"

import logging
logging.basicConfig(level=logging.DEBUG, filename='scripttool.log', filemode='w', format='%(asctime)s - %(levelname)s - %(message)s')

import sys
import subprocess
from pathlib import Path
from tkinter import messagebox

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def set_Tk_var():
    global action_string
    action_string = tk.StringVar()

def init(top, gui, *args, **kwargs):
    global w, top_level, root, minline, all_commands, lastActionBtnClicked
    w = gui
    top_level = top
    root = top
    minline = '--------------------------------------------------\n'
    all_commands = readingCommands()
    all_commands = checkCommands(all_commands)
    root.bind('<Escape>', closeEvent)
    root.protocol("WM_DELETE_WINDOW", closeEvent)

def readingCommands():
    """check if save file exits and read out the commands"""
    if not Path(str(Path.cwd()) + '/script_commands.txt').is_file():
        Path(str(Path.cwd()) + '/script_commands.txt').touch()
    logging.debug('Current working directory: ' + str(Path.cwd()))
    with open('script_commands.txt', 'r') as reader:
        all_commands = [line.rstrip() for line in reader]
        # 'with open' handles the closure of files, even if an error occured
    return all_commands
    
def checkCommands(commands):
    """if file is empty, reset content to default commands and write to file"""
    if len(commands) == 0:
        commands = ['ls -al ~', 'lscpu', 'cat /var/log/rsnapshot.log | tail -n 20',
        'apt-cache search ufw', 'ps -aux', 'systemctl status bluetooth.service']
        saveCommands(commands)
    return commands

def saveCommands(commands):
    with open('script_commands.txt', 'w') as textfile:
        for item in commands:
            textfile.write(str(item) + '\n')
    logging.debug('commands saved to textfile')
    sys.stdout.flush()
    
def restoreToDefaultCommands():
    with open('script_commands.txt', 'w+') as textfile:
        pass
    commands = ''
    global all_commands
    all_commands = checkCommands(commands)
    action_string.set('')
    
def setLastActionBtnClicked(btnNr):
    global lastActionBtnClicked
    lastActionBtnClicked = btnNr
    
def runBtnClicked():
    """call subprocess with the content of Entry1"""
    logging.debug('script_tool_support.runBtnClicked')
    w.Scrolledtext.insert(tk.END, minline)
    
    script_result = subprocess.run(w.Entry1.get(), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if script_result.returncode > 0:
        logging.warning('Returncode: ' + str(script_result.returncode))
    else:
        logging.info('Returncode: ' + str(script_result.returncode))
    strOutput = '\n' + script_result.stdout.decode('utf-8')
    if len(script_result.stderr) > 0:
        strOutput += '\nErrors:\n' + script_result.stderr.decode('utf-8')
        
    # print the output
    w.Scrolledtext.insert(tk.END, strOutput)
    w.Scrolledtext.see(tk.END)
    sys.stdout.flush()

def defaultBtnClicked():
    logging.debug('script_tool_support.defaultBtnClicked')
    restoreToDefaultCommands()
    sys.stdout.flush()

def saveBtnClicked():
    logging.debug('script_tool_support.saveBtnClicked')
    all_commands[lastActionBtnClicked] = w.Entry1.get()
    sys.stdout.flush()

def btn1click():
    logging.debug('script_tool_support.btn1click')
    logging.debug('Commands: ' + str(all_commands[0]))
    action_string.set(all_commands[0])
    setLastActionBtnClicked(0)
    sys.stdout.flush()

def btn2click():
    logging.debug('script_tool_support.btn2click')
    logging.debug('Commands: ' + str(all_commands[1]))
    action_string.set(all_commands[1])
    setLastActionBtnClicked(1)
    sys.stdout.flush()

def btn3click():
    logging.debug('script_tool_support.btn3click')
    logging.debug('Commands: ' + str(all_commands[2]))
    action_string.set(all_commands[2])
    setLastActionBtnClicked(2)
    sys.stdout.flush()

def btn4click():
    logging.debug('script_tool_support.btn4click')
    logging.debug('Commands: ' + str(all_commands[3]))
    action_string.set(all_commands[3])
    setLastActionBtnClicked(3)
    sys.stdout.flush()

def btn5click():
    logging.debug('script_tool_support.btn5click')
    logging.debug('Commands: ' + str(all_commands[4]))
    action_string.set(all_commands[4])
    setLastActionBtnClicked(4)
    sys.stdout.flush()

def btn6click():
    logging.debug('script_tool_support.btn6click')
    logging.debug('Commands: ' + str(all_commands[5]))
    action_string.set(all_commands[5])
    setLastActionBtnClicked(5)
    sys.stdout.flush()

def btnInfo():
    logging.debug('script_tool_support.btnInfo')
    messagebox.showinfo("Script Tool", "Script Tool v" + __version__ + "\n is made by Technout")

def destroy_window():
    # Function which closes the window.
    global top_level
    saveCommands(all_commands) # not working from here?!
    top_level.destroy()
    top_level = None
    
def closeEvent(*args):
    """Handle close event and ask for saving to file"""
    save = messagebox.askyesnocancel("Save and Quit", "Do you want to save commands to file and exit?\n(no means exit without saving)")
    if save:
        saveCommands(all_commands)
        root.destroy()
    elif save == False:
        root.destroy()

if __name__ == '__main__':
    import script_tool
    script_tool.vp_start_gui()





